{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Powerful Toolkit for ActivityPub Implementations. </p> <p> </p> <p>Documentation: https://fedi-libs.github.io/apkit</p> <p>Source Code: https://github.com/fedi-libs/apkit</p> <p>apkit is a modern, fast, and powerful toolkit for building ActivityPub-based applications with Python, based on standard Python type hints.</p> <p>The key features are:</p> <ul> <li>FastAPI-based Server: Build high-performance, production-ready ActivityPub servers with the power and simplicity of FastAPI.</li> <li>Async Client: Interact with other Fediverse servers using a modern <code>async</code> HTTP client.</li> <li>Built-in Helpers: Simplified setup for Webfinger, NodeInfo, HTTP Signatures, and other Fediverse protocols.</li> <li>Extensible: Designed to be flexible and easy to extend for your own custom ActivityPub logic.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> <li>FastAPI for the server part.</li> <li>apmodel for ActivityPub models.</li> <li>apsig for HTTP Signatures.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install apkit\n</code></pre> <p>To include the server components (based on FastAPI), install with the <code>server</code> extra:</p> <pre><code>pip install \"apkit[server]\"\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Create a simple ActivityPub actor and serve it:</p> <pre><code>from apkit.models import Person\nfrom apkit.server import ActivityPubServer\nfrom apkit.server.responses import ActivityResponse\n\napp = ActivityPubServer()\n\nHOST = \"example.com\"\n\nactor = Person(\n    id=f\"https://{HOST}/actor\",\n    name=\"apkit Demo\",\n    preferredUsername=\"demo\",\n    inbox=f\"https://{HOST}/inbox\",\n)\n\n@app.get(\"/actor\")\nasync def get_actor():\n    return ActivityResponse(actor)\n</code></pre> <p>Run the server with <code>uvicorn</code>:</p> <pre><code>$ uvicorn main:app\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"about/","title":"About apkit","text":"<p><code>apkit</code> is a powerful toolkit for Python, designed with the philosophy of making ActivityPub implementation easy, simple, and intuitive for anyone.</p>"},{"location":"about/#the-journey-to-apkit","title":"The Journey to apkit","text":"<p>The developer's journey into the Fediverse began with an interest in Misskey, which led to an attempt to build a custom ActivityPub server named Graphene (Hol0). However, this initial project was unsuccessful due to a lack of deep knowledge, particularly around the complexities of request signing.</p> <p>The direct impetus for <code>apkit</code> came from the development of a new ActivityPub server project, Kagura. Several challenges became clear during its creation:</p> <ol> <li>Lack of Libraries: At the time, there was a scarcity of practical Python libraries for ActivityPub, and many existing options were under restrictive licenses (like GPL/AGPL). </li> <li>Inspiration: The developer was heavily inspired by the <code>Fedify</code> framework in the JavaScript ecosystem and wanted to create a similarly powerful and developer-friendly toolkit for Python.</li> <li>Necessity: The work on Kagura led to the creation of smaller, focused libraries out of necessity. First came <code>apsig</code> to handle HTTP Signatures, followed by <code>apmodel</code> to provide a practical parser for Activity Streams 2.0. <code>apkit</code> was then born to integrate these components into a single, comprehensive framework.</li> </ol>"},{"location":"about/#core-philosophy-and-design","title":"Core Philosophy and Design","text":"<p><code>apkit</code> is designed to be modular, allowing developers to use its components independently or as a complete toolkit. It abstracts away the complexities of the ActivityPub protocol, enabling developers to focus on the core features of their applications and helping to enrich the Fediverse.</p>"},{"location":"about/#comparison-with-alternatives","title":"Comparison with Alternatives","text":"<p>When choosing a library for your ActivityPub project in Python, it's helpful to understand the landscape. Here\u2019s how <code>apkit</code> compares to other notable libraries.</p>"},{"location":"about/#apkit","title":"apkit","text":"<ul> <li>Pros: <code>apkit</code> offers a balance of flexibility and convenience. While it includes a FastAPI-based server component (<code>apkit.server</code>) for rapid development, the core toolkit itself is framework-agnostic. It was developed with an async-first approach but maintains synchronous support. Its permissive MIT license makes it suitable for a wide range of projects.</li> <li>Cons: As a relatively new library, <code>apkit</code> is still immature compared to more established alternatives. The integrated server component is also dependent on FastAPI, which might be a limitation if you are committed to a different web framework.</li> </ul>"},{"location":"about/#pyfed","title":"pyfed","text":"<ul> <li>URL: dev.funkwhale.audio/funkwhale/pyfed</li> <li>Pros: Developed by the team behind Funkwhale, <code>pyfed</code> is an async-first, framework-agnostic library that aims to be a complete and robust ActivityPub implementation. It excels in security and type safety, featuring comprehensive security measures.</li> <li>Cons: It is licensed under the AGPL, which can be a significant constraint for commercial or closed-source projects.</li> </ul>"},{"location":"about/#bovine","title":"bovine","text":"<ul> <li>URL: bovine.readthedocs.io</li> <li>Pros: <code>bovine</code> is highly modular, functioning more like a set of building blocks than a monolithic library. Its design philosophy influenced <code>apkit</code>.</li> <li>Cons: Its structure may feel closer to a server implementation than a general-purpose toolkit, which could be less intuitive for developers looking for a simple library to integrate into an existing application.</li> </ul>"},{"location":"about/#fedify","title":"Fedify","text":"<ul> <li>URL: fedify.dev</li> <li><code>Fedify</code> is a major source of inspiration for <code>apkit</code>'s design and developer experience. However, it is a TypeScript/JavaScript library and cannot be used directly in Python projects.</li> </ul>"},{"location":"about/#direct-implementation-without-a-library","title":"Direct Implementation (Without a Library)","text":"<p>You might also consider implementing the ActivityPub protocol directly without relying on a third-party library.</p> <ul> <li>Pros: This approach gives you complete control over every aspect of the implementation and avoids adding external dependencies to your project. For very simple use cases, this might seem viable.</li> <li>Cons: The complexity of the ActivityPub specification is significant. As illustrated by the history of <code>apkit</code>, even experienced developers can face major hurdles with core components like HTTP Signatures. Building everything from scratch requires a deep understanding of the protocol, a substantial investment of time and effort, and the ongoing burden of maintenance and security. You would be \"reinventing the wheel,\" which libraries like <code>apkit</code> are designed to prevent. If you still choose this path, it is highly recommended to use a dedicated library for HTTP Signatures, such as <code>apsig</code>, to handle this critical and complex part.</li> </ul>"},{"location":"tutorial/","title":"Getting Started with apkit","text":"<p>This tutorial will guide you through creating a basic ActivityPub server using <code>apkit</code>. You'll learn how to create an actor, make it discoverable, and handle incoming <code>Follow</code> requests.</p>"},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<p><code>apkit</code>'s server module is built on FastAPI. To get started, you'll need to install <code>apkit</code> with the <code>server</code> extras.</p> <pre><code>pip install \"apkit[server]\"\n</code></pre> <p>You will also need an ASGI server to run your application. We'll use <code>uvicorn</code> in this tutorial.</p> <pre><code>pip install uvicorn\n</code></pre>"},{"location":"tutorial/#1-basic-server-and-actor-setup","title":"1. Basic Server and Actor Setup","text":"<p>First, let's import the necessary components and set up a basic server and a <code>Person</code> actor.</p> <pre><code># main.py\nimport uuid\nfrom fastapi import Request, Response\nfrom fastapi.responses import JSONResponse\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization as crypto_serialization\n\nfrom apkit.server import ActivityPubServer, SubRouter\nfrom apkit.server.types import Context, ActorKey\nfrom apkit.server.responses import ActivityResponse\nfrom apkit.models import (\n    Person, CryptographicKey, Follow, Actor as APKitActor,\n    Nodeinfo, NodeinfoSoftware, NodeinfoProtocol, NodeinfoServices, NodeinfoUsage, NodeinfoUsageUsers\n)\nfrom apkit.client import WebfingerResource, WebfingerResult, WebfingerLink\nfrom apkit.client.asyncio.client import ActivityPubClient\n\n# --- Configuration ---\nHOST = \"example.com\"\nUSER_ID = str(uuid.uuid4())\n\n# --- Key Generation (for demonstration) ---\n# In a real application, you would load a persistent key from a secure storage.\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key_pem = private_key.public_key().public_bytes(\n    encoding=crypto_serialization.Encoding.PEM,\n    format=crypto_serialization.PublicFormat.SubjectPublicKeyInfo\n).decode('utf-8')\n\n# --- Actor Definition ---\nactor = Person(\n    id=f\"https://{HOST}/users/{USER_ID}\",\n    name=\"apkit Demo\",\n    preferredUsername=\"demo\",\n    summary=\"This is a demo actor powered by apkit!\",\n    inbox=f\"https://{HOST}/users/{USER_ID}/inbox\",\n    outbox=f\"https://{HOST}/users/{USER_ID}/outbox\",\n    publicKey=CryptographicKey(\n        id=f\"https://{HOST}/users/{USER_ID}#main-key\",\n        owner=f\"https://{HOST}/users/{USER_ID}\",\n        publicKeyPem=public_key_pem\n    )\n)\n\n# --- Server Initialization ---\napp = ActivityPubServer()\n</code></pre>"},{"location":"tutorial/#2-serving-the-actor","title":"2. Serving the Actor","text":"<p>To make your actor accessible to others, you need an endpoint that serves the actor object.</p> <pre><code># main.py (continued)\n@app.get(\"/users/{identifier}\")\nasync def get_actor_endpoint(identifier: str):\n    if identifier == USER_ID:\n        return ActivityResponse(actor)\n    return JSONResponse({\"error\": \"Not Found\"}, status_code=404)\n</code></pre>"},{"location":"tutorial/#3-making-the-actor-discoverable-with-webfinger","title":"3. Making the Actor Discoverable with Webfinger","text":"<p>Webfinger allows users on other servers to find your actor using an address like <code>demo@example.com</code>.</p> <pre><code># main.py (continued)\n@app.webfinger()\nasync def webfinger_endpoint(request: Request, acct: WebfingerResource) -&gt; Response:\n    if acct.username == \"demo\" and acct.host == HOST:\n        link = WebfingerLink(\n            rel=\"self\",\n            type=\"application/activity+json\",\n            href=f\"https://{HOST}/users/{USER_ID}\"\n        )\n        wf_result = WebfingerResult(subject=acct, links=[link])\n        return JSONResponse(wf_result.to_json(), media_type=\"application/jrd+json\")\n    return JSONResponse({\"message\": \"Not Found\"}, status_code=404)\n</code></pre>"},{"location":"tutorial/#4-setting-up-the-inbox","title":"4. Setting up the Inbox","text":"<p>Before your server can receive activities, you need to define an inbox endpoint. The <code>app.inbox()</code> method registers a URL pattern as an inbox. Any valid POST request to this URL will be processed by your activity handlers.</p> <pre><code># main.py (continued)\napp.inbox(\"/users/{identifier}/inbox\")\n</code></pre>"},{"location":"tutorial/#5-handling-incoming-activities","title":"5. Handling Incoming Activities","text":"<p>The <code>@app.on()</code> decorator registers a handler for specific incoming activities. Let's create a handler for <code>Follow</code> requests that automatically sends back a signed <code>Accept</code> activity.</p> <pre><code># main.py (continued)\n\n# This function provides the private key for signing outgoing activities.\nasync def get_keys_for_actor(identifier: str) -&gt; list[ActorKey]:\n    if identifier == USER_ID:\n        return [ActorKey(key_id=actor.publicKey.id, private_key=private_key)]\n    return []\n\n@app.on(Follow)\nasync def on_follow_activity(ctx: Context):\n    activity = ctx.activity\n    if not isinstance(activity, Follow):\n        return JSONResponse({\"error\": \"Invalid activity type\"}, status_code=400)\n\n    # Resolve the actor who sent the Follow request\n    follower_actor = None\n    if isinstance(activity.actor, str):\n        async with ActivityPubClient() as client:\n            follower_actor = await client.actor.fetch(activity.actor)\n    elif isinstance(activity.actor, APKitActor):\n        follower_actor = activity.actor\n\n    if not follower_actor:\n        return JSONResponse({\"error\": \"Could not resolve follower actor\"}, status_code=400)\n\n    # Automatically accept the follow request\n    accept_activity = activity.accept()\n\n    # Send the signed Accept activity back to the follower's inbox\n    await ctx.send(\n        get_keys_for_actor,\n        follower_actor,\n        accept_activity\n    )\n    return Response(status_code=202)\n</code></pre>"},{"location":"tutorial/#6-adding-server-metadata-with-nodeinfo","title":"6. Adding Server Metadata with NodeInfo","text":"<p>NodeInfo is a protocol to publish standardized metadata about your server. <code>apkit</code> provides a simple decorator to expose this information.</p> <pre><code># main.py (continued)\n@app.nodeinfo(\"/nodeinfo/2.1\", \"2.1\")\nasync def nodeinfo_endpoint():\n    return ActivityResponse(\n        Nodeinfo(\n            version=\"2.1\",\n            software=NodeinfoSoftware(name=\"apkit-demo\", version=\"0.1.0\"),\n            protocols=[NodeinfoProtocol.ACTIVITYPUB],\n            services=NodeinfoServices(inbound=[], outbound=[]),\n            openRegistrations=False,\n            usage=NodeinfoUsage(users=NodeinfoUsageUsers(total=1)),\n            metadata={},\n        )\n    )\n</code></pre>"},{"location":"tutorial/#7-organizing-your-code-with-subrouter","title":"7. Organizing your code with SubRouter","text":"<p>For larger applications, you can use <code>SubRouter</code>, which works just like FastAPI's <code>APIRouter</code>. It allows you to organize your endpoints into different files. <code>SubRouter</code> also supports <code>apkit</code>-specific decorators like <code>@sub.nodeinfo()</code>.</p> <pre><code># main.py (continued)\n# You could move this to a separate file, e.g., `nodeinfo.py`\nsub = SubRouter()\n\n@sub.nodeinfo(\"/ni/2.0\", \"2.0\")\nasync def nodeinfo_20_endpoint():\n    # ... (implementation similar to the above)\n    pass\n\napp.include_router(sub)\n</code></pre>"},{"location":"tutorial/#8-running-the-server","title":"8. Running the Server","text":"<p>Save the complete code to a file named <code>main.py</code>. You can then run it with <code>uvicorn</code>.</p> <pre><code>uvicorn main:app --host 0.0.0.0 --port 8000\n</code></pre> <p>Your simple ActivityPub server is now running! You can test it by searching for <code>@demo@example.com</code> from another Fediverse instance.</p>"},{"location":"tutorial/#9-full-code-example","title":"9. Full Code Example","text":"<p>Here is the complete code for <code>main.py</code>:</p> <pre><code>import uuid\nfrom fastapi import Request, Response\nfrom fastapi.responses import JSONResponse\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization as crypto_serialization\n\nfrom apkit.server import ActivityPubServer, SubRouter\nfrom apkit.server.types import Context, ActorKey\nfrom apkit.server.responses import ActivityResponse\nfrom apkit.models import (\n    Person, CryptographicKey, Follow, Actor as APKitActor,\n    Nodeinfo, NodeinfoSoftware, NodeinfoProtocol, NodeinfoServices, NodeinfoUsage, NodeinfoUsageUsers\n)\nfrom apkit.client import WebfingerResource, WebfingerResult, WebfingerLink\nfrom apkit.client.asyncio.client import ActivityPubClient\n\n# --- Configuration ---\nHOST = \"example.com\"\nUSER_ID = str(uuid.uuid4())\n\n# --- Key Generation (for demonstration) ---\n# In a real application, you would load a persistent key from a secure storage.\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key_pem = private_key.public_key().public_bytes(\n    encoding=crypto_serialization.Encoding.PEM,\n    format=crypto_serialization.PublicFormat.SubjectPublicKeyInfo\n).decode('utf-8')\n\n# --- Actor Definition ---\nactor = Person(\n    id=f\"https://{HOST}/users/{USER_ID}\",\n    name=\"apkit Demo\",\n    preferredUsername=\"demo\",\n    summary=\"This is a demo actor powered by apkit!\",\n    inbox=f\"https://{HOST}/users/{USER_ID}/inbox\",\n    outbox=f\"https://{HOST}/users/{USER_ID}/outbox\",\n    publicKey=CryptographicKey(\n        id=f\"https://{HOST}/users/{USER_ID}#main-key\",\n        owner=f\"https://{HOST}/users/{USER_ID}\",\n        publicKeyPem=public_key_pem\n    )\n)\n\n# --- Server Initialization ---\napp = ActivityPubServer()\n\n# --- Key Retrieval Function ---\n# This function provides the private key for signing outgoing activities.\nasync def get_keys_for_actor(identifier: str) -&gt; list[ActorKey]:\n    if identifier == USER_ID:\n        return [ActorKey(key_id=actor.publicKey.id, private_key=private_key)]\n    return []\n\n# --- Endpoints ---\napp.inbox(\"/users/{identifier}/inbox\")\n\n@app.get(\"/users/{identifier}\")\nasync def get_actor_endpoint(identifier: str):\n    if identifier == USER_ID:\n        return ActivityResponse(actor)\n    return JSONResponse({\"error\": \"Not Found\"}, status_code=404)\n\n@app.webfinger()\nasync def webfinger_endpoint(request: Request, acct: WebfingerResource) -&gt; Response:\n    if acct.username == \"demo\" and acct.host == HOST:\n        link = WebfingerLink(\n            rel=\"self\",\n            type=\"application/activity+json\",\n            href=f\"https://{HOST}/users/{USER_ID}\"\n        )\n        wf_result = WebfingerResult(subject=acct, links=[link])\n        return JSONResponse(wf_result.to_json(), media_type=\"application/jrd+json\")\n    return JSONResponse({\"message\": \"Not Found\"}, status_code=404)\n\n@app.nodeinfo(\"/nodeinfo/2.1\", \"2.1\")\nasync def nodeinfo_endpoint():\n    return ActivityResponse(\n        Nodeinfo(\n            version=\"2.1\",\n            software=NodeinfoSoftware(name=\"apkit-demo\", version=\"0.1.0\"),\n            protocols=[NodeinfoProtocol.ACTIVITYPUB],\n            services=NodeinfoServices(inbound=[], outbound=[]),\n            openRegistrations=False,\n            usage=NodeinfoUsage(users=NodeinfoUsageUsers(total=1)),\n            metadata={},\n        )\n    )\n\n# --- Activity Handlers ---\n@app.on(Follow)\nasync def on_follow_activity(ctx: Context):\n    activity = ctx.activity\n    if not isinstance(activity, Follow):\n        return JSONResponse({\"error\": \"Invalid activity type\"}, status_code=400)\n\n    # Resolve the actor who sent the Follow request\n    follower_actor = None\n    if isinstance(activity.actor, str):\n        async with ActivityPubClient() as client:\n            follower_actor = await client.actor.fetch(activity.actor)\n    elif isinstance(activity.actor, APKitActor):\n        follower_actor = activity.actor\n\n    if not follower_actor:\n        return JSONResponse({\"error\": \"Could not resolve follower actor\"}, status_code=400)\n\n    # Automatically accept the follow request\n    accept_activity = activity.accept()\n\n    # Send the signed Accept activity back to the follower's inbox\n    await ctx.send(\n        get_keys_for_actor,\n        follower_actor,\n        accept_activity\n    )\n    return Response(status_code=202)\n</code></pre>"},{"location":"guides/","title":"In-Depth Guides","text":"<p>This section provides in-depth guides to the various components of <code>apkit</code>.</p> <p>Choose a topic to learn more:</p> <ul> <li>Configuration</li> <li>Using the Client</li> <li>Advanced Server Features</li> <li>Working with Models</li> <li>Key-Value Storage</li> </ul>"},{"location":"guides/client/","title":"Using the Client","text":"<p>The <code>apkit.client</code> module provides clients for communicating with other ActivityPub servers. There are two types of clients available:</p> <ul> <li>Asynchronous Client (<code>apkit.client.asyncio</code>): This client is based on <code>aiohttp</code> and is suitable for applications that require non-blocking I/O operations. It's the recommended choice for web servers and other high-concurrency applications.</li> <li>Synchronous Client (<code>apkit.client.sync</code>): This client is based on <code>httpcore</code> (the foundation of <code>httpx</code>) and provides a blocking, synchronous interface. It's easier to use in scripts or applications that don't require the complexity of <code>asyncio</code>.</li> </ul> <p>The choice between the two depends on your application's architecture. The asynchronous client offers better performance for I/O-bound tasks, while the synchronous client is simpler to integrate into traditional, linear programs.</p> <p>This is a very simple example:</p> AsynchronousSynchronous <pre><code>import asyncio\nfrom apkit.client.asyncio import ActivityPubClient\n\nasync def main():\n    async with ActivityPubClient() as client:\n        # Fetch a remote Actor or Object\n        actor = await client.actor.fetch(\"https://example.com/users/someuser\")\n        if actor:\n            print(f\"Fetched actor: {actor.name}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <pre><code>from apkit.client.sync import ActivityPubClient\n\ndef main():\n    with ActivityPubClient() as client:\n        # Fetch a remote Actor or Object\n        actor = client.actor.fetch(\"https://example.com/users/someuser\")\n        if actor:\n            print(f\"Fetched actor: {actor.name}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>When sending activities to another server, this server usually wants to verify the signature. This requires some interaction. Therefore, it is easiest to start the minimal server from the tutorial. It will take care to answer the WebFinger requests, send the required <code>application/activity+json</code> documents and public key.</p>"},{"location":"guides/client/#create-a-note","title":"Create a Note","text":"<p>This is a simple example to send a Note to another ActivityPub server. First, some preparations need to be made, which must be done only once before all activities.</p> <ol> <li>The programs loads or creates a private key required to sign activities.</li> <li>A Person resource is created that will be used as the Actor of activities.</li> </ol> <p>The function <code>send_note</code> contains the code to create a Note.</p> <ol> <li>Find the address of the receiver's inbox.</li> <li>Create a Note object.</li> <li>Create a Create activity that contains the Note.</li> <li>Deliver the Create activity to the receiver's inbox.</li> </ol> AsynchronousSynchronous <pre><code>import asyncio\nimport logging\nimport os\nimport uuid\n\nfrom apkit.client.asyncio import ActivityPubClient\nfrom apkit.models import Person, Note, CryptographicKey, Create, Delete\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization as crypto_serialization\nfrom datetime import datetime, UTC\n\nHOST=\"social.example.com\"      # &lt;&lt;&lt; Change this to your domain name\nUSER_ID=\"demo\"\nTARGET_ID=\"https://example.org/users/alice\"   # &lt;&lt;&lt; Change this to the URI of the account you want to send something to\n\n# --- Logging Setup ---\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# --- Key Persistence ---\nKEY_FILE = \"private_key.pem\"\n\nif os.path.exists(KEY_FILE):\n    logger.info(f\"Loading existing private key from {KEY_FILE}.\")\n    with open(KEY_FILE, \"rb\") as f:\n        private_key = crypto_serialization.load_pem_private_key(f.read(), password=None)\nelse:\n    logger.info(f\"No key file found. Generating new private key and saving to {KEY_FILE}.\")\n    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n    with open(KEY_FILE, \"wb\") as f:\n        f.write(private_key.private_bytes(\n            encoding=crypto_serialization.Encoding.PEM,\n            format=crypto_serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=crypto_serialization.NoEncryption()\n        ))\n\npublic_key_pem = private_key.public_key().public_bytes(\n    encoding=crypto_serialization.Encoding.PEM,\n    format=crypto_serialization.PublicFormat.SubjectPublicKeyInfo\n).decode('utf-8')\n\n# --- Create actor ---\nactor = Person(\n    id=f\"https://{HOST}/users/{USER_ID}\",\n    name=\"apkit Demo\",\n    preferredUsername=\"demo\",\n    summary=\"This is a demo actor powered by apkit!\",\n    inbox=f\"https://{HOST}/users/{USER_ID}/inbox\",\n    outbox=f\"https://{HOST}/users/{USER_ID}/outbox\",\n    publicKey=CryptographicKey(\n        id=f\"https://{HOST}/users/{USER_ID}#main-key\",\n        owner=f\"https://{HOST}/users/{USER_ID}\",\n        publicKeyPem=public_key_pem\n    )\n)\n\nasync def send_note():\n    async with ActivityPubClient() as client:\n        # Fetch a remote Actor\n        target_actor = await client.actor.fetch(TARGET_ID)\n        print(f\"Fetched actor: {target_actor.name}\")\n\n        # Get the inbox URL from the actor's profile\n        inbox_url = target_actor.inbox\n        if not inbox_url:\n            raise Exception(\"Could not find actor's inbox URL\")\n\n        logger.info(f\"Found actor's inbox: {inbox_url}\")\n\n        # --- Create note ---\n        note = Note(\n            id=f\"https://{HOST}/notes/{uuid.uuid4()}\",\n            attributedTo=actor.id,\n            content=f\"&lt;p&gt;Hello from apkit&lt;/p&gt;\",\n            published=datetime.now(UTC).isoformat().replace(\"+00:00\", \"Z\"),\n            to=[target_actor.id],\n            cc=[\"https://www.w3.org/ns/activitystreams#Public\"],\n        )\n\n        # --- Create activity ---\n        create = Create(\n            id=f\"https://{HOST}/creates/{uuid.uuid4()}\",\n            actor=actor.id,\n            object=note.to_json(),            # embed the note into the activity\n            published=datetime.now(UTC).isoformat().replace(\"+00:00\", \"Z\"),\n            to=note.to,                       # re-use the information from the note\n            cc=note.cc\n        )\n\n        # Deliver the activity\n        logger.info(\"Delivering activity...\")\n\n        # If you are interested in the actual data, uncomment this line.\n        # print(create.to_json())\n\n        resp = await client.post(\n            inbox_url,                  # address of the receiver's inbox\n            key_id=actor.publicKey.id,  # the id of our public key\n            signature=private_key,      # this is our private key\n            json=create                 # the activity to send\n        )\n        logger.info(f\"Delivery result: {resp.status}\")\n        logger.info(f\"Note id: {note.id}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(send_note())\n</code></pre> <pre><code>import logging\nimport os\nimport uuid\n\nfrom apkit.client.sync import ActivityPubClient\nfrom apkit.models import Person, Note, CryptographicKey, Create, Delete\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization as crypto_serialization\nfrom datetime import datetime, UTC\n\nHOST=\"social.example.com\"      # &lt;&lt;&lt; Change this to your domain name\nUSER_ID=\"demo\"\nTARGET_ID=\"https://example.org/users/alice\"   # &lt;&lt;&lt; Change this to the URI of the account you want to send something to\n\n# --- Logging Setup ---\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# --- Key Persistence ---\nKEY_FILE = \"private_key.pem\"\n\nif os.path.exists(KEY_FILE):\n    logger.info(f\"Loading existing private key from {KEY_FILE}.\")\n    with open(KEY_FILE, \"rb\") as f:\n        private_key = crypto_serialization.load_pem_private_key(f.read(), password=None)\nelse:\n    logger.info(f\"No key file found. Generating new private key and saving to {KEY_FILE}.\")\n    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n    with open(KEY_FILE, \"wb\") as f:\n        f.write(private_key.private_bytes(\n            encoding=crypto_serialization.Encoding.PEM,\n            format=crypto_serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=crypto_serialization.NoEncryption()\n        ))\n\npublic_key_pem = private_key.public_key().public_bytes(\n    encoding=crypto_serialization.Encoding.PEM,\n    format=crypto_serialization.PublicFormat.SubjectPublicKeyInfo\n).decode('utf-8')\n\n# --- Create actor ---\nactor = Person(\n    id=f\"https://{HOST}/users/{USER_ID}\",\n    name=\"apkit Demo\",\n    preferredUsername=\"demo\",\n    summary=\"This is a demo actor powered by apkit!\",\n    inbox=f\"https://{HOST}/users/{USER_ID}/inbox\",\n    outbox=f\"https://{HOST}/users/{USER_ID}/outbox\",\n    publicKey=CryptographicKey(\n        id=f\"https://{HOST}/users/{USER_ID}#main-key\",\n        owner=f\"https://{HOST}/users/{USER_ID}\",\n        publicKeyPem=public_key_pem\n    )\n)\n\ndef send_note():\n    with ActivityPubClient() as client:\n        # Fetch a remote Actor\n        target_actor = client.actor.fetch(TARGET_ID)\n        print(f\"Fetched actor: {target_actor.name}\")\n\n        # Get the inbox URL from the actor's profile\n        inbox_url = target_actor.inbox\n        if not inbox_url:\n            raise Exception(\"Could not find actor's inbox URL\")\n\n        logger.info(f\"Found actor's inbox: {inbox_url}\")\n\n        # --- Create note ---\n        note = Note(\n            id=f\"https://{HOST}/notes/{uuid.uuid4()}\",\n            attributedTo=actor.id,\n            content=f\"&lt;p&gt;Hello from apkit&lt;/p&gt;\",\n            published=datetime.now(UTC).isoformat().replace(\"+00:00\", \"Z\"),\n            to=[target_actor.id],\n            cc=[\"https://www.w3.org/ns/activitystreams#Public\"],\n        )\n\n        # --- Create activity ---\n        create = Create(\n            id=f\"https://{HOST}/creates/{uuid.uuid4()}\",\n            actor=actor.id,\n            object=note.to_json(),            # embed the note into the activity\n            published=datetime.now(UTC).isoformat().replace(\"+00:00\", \"Z\"),\n            to=note.to,                       # re-use the information from the note\n            cc=note.cc\n        )\n\n        # Deliver the activity\n        logger.info(\"Delivering activity...\")\n\n        # If you are interested in the actual data, uncomment this line.\n        # print(create.to_json())\n\n        resp = client.post(\n            inbox_url,                  # address of the receiver's inbox\n            key_id=actor.publicKey.id,  # the id of our public key\n            signature=private_key,      # this is our private key\n            json=create                 # the activity to send\n        )\n        logger.info(f\"Delivery result: {resp.status}\")\n        logger.info(f\"Note id: {note.id}\")\n\nif __name__ == \"__main__\":\n    send_note()\n</code></pre> <p>In a productiv environment you will want to store the content of the note and its URI into some kind of persistent storage. Then, for example, likes could be correctly assigned.</p>"},{"location":"guides/client/#delete-something","title":"Delete something","text":"<p>The last information the function to create a Note writes on the terminal is the URI by which the Note can be identified. It can also be used to remove it from another ActivityPub server. Here is some demo code for that:</p> AsynchronousSynchronous <pre><code>async def delete_note():\n\n    URI = \"https://social.example.com/notes/6de49020-85a0-4546-b63e-36fe23271f71\"   # &lt;&lt;&lt; change this URI\n\n    async with ActivityPubClient() as client:\n        # Fetch a remote Actor\n        target_actor = await client.actor.fetch(TARGET_ID)\n        print(f\"Fetched actor: {target_actor.name}\")\n\n        # Get the inbox URL from the actor's profile\n        inbox_url = target_actor.inbox\n        if not inbox_url:\n            raise Exception(\"Could not find actor's inbox URL\")\n\n        logger.info(f\"Found actor's inbox: {inbox_url}\")\n\n        # Delete activity\n        delete = Delete(\n            id=f\"https://{HOST}/activities/{uuid.uuid4()}\",\n            actor=actor.id,\n            object=URI,\n            published=datetime.now(UTC).isoformat().replace(\"+00:00\", \"Z\"),\n            to=[target_actor.id],\n            cc=[\"https://www.w3.org/ns/activitystreams#Public\"],\n        )\n\n        # Deliver the activity\n        logger.info(\"Delivering activity...\")\n\n        resp = await client.post(\n            inbox_url,\n            key_id=actor.publicKey.id,\n            signature=private_key,\n            json=delete\n        )\n        logger.info(f\"Delivery result: {resp.status}\")\n</code></pre> <pre><code>def delete_note():\n\n    URI = \"https://social.example.com/notes/6de49020-85a0-4546-b63e-36fe23271f71\"   # &lt;&lt;&lt; change this URI\n\n    with ActivityPubClient() as client:\n        # Fetch a remote Actor\n        target_actor = client.actor.fetch(TARGET_ID)\n        print(f\"Fetched actor: {target_actor.name}\")\n\n        # Get the inbox URL from the actor's profile\n        inbox_url = target_actor.inbox\n        if not inbox_url:\n            raise Exception(\"Could not find actor's inbox URL\")\n\n        logger.info(f\"Found actor's inbox: {inbox_url}\")\n\n        # Delete activity\n        delete = Delete(\n            id=f\"https://{HOST}/activities/{uuid.uuid4()}\",\n            actor=actor.id,\n            object=URI,\n            published=datetime.now(UTC).isoformat().replace(\"+00:00\", \"Z\"),\n            to=[target_actor.id],\n            cc=[\"https://www.w3.org/ns/activitystreams#Public\"],\n        )\n\n        # Deliver the activity\n        logger.info(\"Delivering activity...\")\n\n        resp = client.post(\n            inbox_url,\n            key_id=actor.publicKey.id,\n            signature=private_key,\n            json=delete\n        )\n        logger.info(f\"Delivery result: {resp.status}\")\n</code></pre>"},{"location":"guides/configuration/","title":"Configuration","text":"<p><code>apkit</code>'s behavior is configured through the <code>apkit.config.AppConfig</code> class. Currently, the main configuration option is <code>actor_keys</code>.</p> <p>You should provide an async function to <code>actor_keys</code> that returns the private keys for the actors managed by your server. This function is called whenever <code>apkit</code> needs to sign an activity before sending it to another server.</p> <pre><code>from apkit.config import AppConfig\nfrom apkit.server.types import ActorKey\n\n# This function is responsible for returning the appropriate\n# private key based on the request context.\nasync def get_my_actor_keys(identifier: str) -&gt; list[ActorKey]:\n    # ... Logic to fetch keys from a database or elsewhere ...\n    if identifier == \"user123\":\n        return [ActorKey(key_id=\"https://example.com/users/user123#main-key\", private_key=...)]\n    return []\n\napp_config = AppConfig(\n    actor_keys=get_my_actor_keys\n)\n\napp = ActivityPubServer(apkit_config=app_config)\n</code></pre>"},{"location":"guides/kv_store/","title":"Key-Value Storage","text":"<p><code>apkit.kv</code> provides an abstraction layer for a simple key-value store. By default, an in-memory store is used, but you can also use Redis as a backend by installing the <code>redis</code> extra.</p> <p>This can be used for various purposes, such as caching or storing temporary data.</p> <pre><code>from apkit.kv.inmemory import InMemoryKV\n\nkv = InMemoryKV()\n\nawait kv.set(\"my_key\", {\"data\": \"some_value\"})\nvalue = await kv.get(\"my_key\")\n</code></pre>"},{"location":"guides/models/","title":"Working with Models","text":"<p>The ActivityPub object models used by <code>apkit</code> are provided by the <code>apmodel</code> library. These are defined as standard Python <code>dataclasses</code>, not Pydantic models.</p> <p>This allows you to benefit from type hinting, autocompletion, and static analysis while working with lightweight and easy-to-handle objects for your ActivityPub data.</p> <pre><code>from apkit.models import Person\n\n# Can be instantiated like a normal dataclass\nnew_person = Person(\n    id=\"https://example.com/new_person\",\n    name=\"New Person\"\n)\n</code></pre>"},{"location":"guides/server/","title":"Advanced Server Features","text":""},{"location":"guides/server/#handling-various-activities","title":"Handling Various Activities","text":"<p>The <code>@app.on()</code> decorator can handle any type of ActivityPub activity, such as <code>Create</code>, <code>Like</code>, <code>Announce</code>, and <code>Undo</code>, in addition to <code>Follow</code>. By specifying the activity type as an argument, the handler will be executed when that activity is POSTed to the inbox.</p> <pre><code>from apkit.models import Create, Undo, Like\nfrom apkit.server.types import Context\n\n@app.on(Create)\nasync def on_create(ctx: Context):\n    activity = ctx.activity\n    if not isinstance(activity, Create): return\n    # Process Create activity\n    print(f\"Received Create activity: {activity.id}\")\n\n@app.on(Undo)\nasync def on_undo(ctx: Context):\n    activity = ctx.activity\n    if not isinstance(activity, Undo): return\n    # Process Undo activity (e.g., undoing a Like)\n    if isinstance(activity.object, Like):\n        print(f\"Undo Like: {activity.object.id}\")\n</code></pre>"},{"location":"guides/server/#structuring-with-subrouter","title":"Structuring with <code>SubRouter</code>","text":"<p>As your application grows, you can use <code>SubRouter</code> to modularize your endpoints, similar to FastAPI's <code>APIRouter</code>. <code>apkit</code>-specific decorators like <code>@sub.nodeinfo()</code> are also available on <code>SubRouter</code>.</p> <pre><code># in routes/nodeinfo.py\nfrom apkit.server import SubRouter\n\nsub = SubRouter()\n\n@sub.nodeinfo(\"/ni/2.0\", \"2.0\")\nasync def nodeinfo_20_endpoint():\n    # ...\n    pass\n\n# in main.py\nfrom routes.nodeinfo import sub as nodeinfo_router\n\napp.include_router(nodeinfo_router)\n</code></pre>"},{"location":"resources/","title":"Resources","text":"<p>This section provides resources for contributors and anyone interested in the technologies behind <code>apkit</code>.</p> <ul> <li>Contribution Guide</li> <li>Useful Links</li> </ul>"},{"location":"resources/contributing/","title":"Contribution Guide","text":"<p>Thank you for your interest in contributing to <code>apkit</code>! To ensure a smooth collaboration, please read and follow these guidelines.</p>"},{"location":"resources/contributing/#communication","title":"Communication","text":"<p>We encourage all Pull Requests and Issues to be written in English. This helps more developers understand the context and participate in the discussion. If you're not a native English speaker, don't worry\u2014just do your best! We appreciate any effort to make communication accessible to everyone. Don't worry about perfect English\u2014the main developer isn't a native speaker either, so we're all in the same boat! \ud83d\ude09 </p>"},{"location":"resources/contributing/#code-standards","title":"Code Standards","text":""},{"location":"resources/contributing/#type-hints","title":"Type Hints","text":"<p>Please use type hints for all new code. This improves readability and allows for static analysis, which helps catch potential bugs early.</p>"},{"location":"resources/contributing/#kiss-principle","title":"KISS Principle","text":"<p>We adhere to the Keep It Simple, Stupid (KISS) principle. Please write code that is as simple and straightforward as possible. Avoid overly complex logic or unnecessary code that could make future maintenance difficult for others.</p>"},{"location":"resources/contributing/#commit-messages","title":"Commit Messages","text":"<p>All commit messages must follow the Conventional Commits specification. This makes our commit history clear and easy to read, and it helps with automated changelog generation.</p> <p>Examples of Conventional Commits:</p> <ul> <li><code>feat: add new feature</code></li> <li><code>fix: resolve a bug</code></li> <li><code>docs: update documentation</code></li> <li><code>refactor: refactor code without changing functionality</code></li> </ul>"},{"location":"resources/contributing/#pull-request-locations","title":"Pull Request Locations","text":"<p>To keep our projects organized, please submit your Pull Requests to the correct repository:</p> <ul> <li>For signature verification/creation, please submit your PR to the <code>apsig</code> repository.</li> <li>For loading and outputting models that include ActivityStreams, please submit your PR to the <code>apmodel</code> repository.</li> <li>Please submit Pull Requests for features that are not fundamental to apsig or apmodel, such as signature verification for requests sent to the inbox or double-knocking functionality for RFC9421-based signatures, to the apkit repository.</li> </ul>"},{"location":"resources/security/","title":"Security Policy","text":"<p>The <code>apkit</code> team takes security seriously and is committed to responsible disclosure. We appreciate your efforts to responsibly disclose your findings, and we will make every effort to acknowledge your contributions.</p>"},{"location":"resources/security/#supported-versions","title":"Supported Versions","text":"<p>As a small, open-source project, our resources are limited. Therefore, we can only provide security patches for the most recent version of <code>apkit</code>. Please ensure you are using the latest version before submitting a report.</p>"},{"location":"resources/security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>If you believe you have found a security vulnerability in <code>apkit</code> or any of its related projects (<code>apmodel</code>, <code>apsig</code>), please report it to us privately.</p> <p>Please do not report security vulnerabilities through public GitHub issues.</p> <p>Instead, please send an email to <code>cocoa@amase.cc</code>.</p> <p>Please include the following details with your report:</p> <ul> <li>A description of the vulnerability and its potential impact.</li> <li>Steps to reproduce the vulnerability.</li> <li>Any proof-of-concept code.</li> </ul>"},{"location":"resources/security/#our-commitment","title":"Our Commitment","text":"<ul> <li>We will acknowledge receipt of your vulnerability report as soon as possible.</li> <li>We will work with you to understand and validate the issue.</li> <li>We will work to release a patch in a timely manner.</li> </ul> <p>We thank you for helping to keep <code>apkit</code> and its users safe.</p>"},{"location":"resources/useful_links/","title":"Useful Links","text":"<p>This page contains a curated list of links to specifications, protocols, and other resources relevant to <code>apkit</code> and Fediverse development.</p>"},{"location":"resources/useful_links/#specifications-and-protocols","title":"Specifications and Protocols","text":"<p>These are the core standards that <code>apkit</code> helps you implement.</p> <ul> <li>ActivityPub: The main W3C recommendation for a decentralized social networking protocol.</li> <li>ActivityStreams 2.0: The data format used by ActivityPub to represent activities and objects.</li> <li>Webfinger: A protocol for discovering information about people or other entities on the internet, used in the Fediverse to find user accounts.</li> <li>HTTP Signatures: The mechanism used to secure messages between servers.</li> <li>NodeInfo: A protocol for exposing standardized metadata about a server.</li> </ul>"},{"location":"resources/useful_links/#apkit-related-guides-and-resources","title":"apkit-related Guides and Resources","text":"<p>This section includes links to the source code for <code>apkit</code> and its core dependencies, as well as articles and community resources.</p>"},{"location":"resources/useful_links/#project-repositories","title":"Project Repositories","text":"<ul> <li>apkit Source Code: The main repository for the <code>apkit</code> toolkit.</li> <li>apmodel Source Code: The library that provides the <code>dataclass</code>-based models for ActivityStreams 2.0 objects.</li> <li>apsig Source Code: The library used for handling HTTP Signatures.</li> </ul>"},{"location":"resources/useful_links/#community","title":"Community","text":"<p>Add your project!</p> <p>Are you using <code>apkit</code> in your project? We'd love to feature it here! Please open a pull request to add it to the list.</p> <ul> <li>How to Build a Simple ActivityPub Reminder Bot in Python (Python\u3068ActivityPub\u3067\u30ea\u30de\u30a4\u30f3\u30c0\u30fcBot\u3092\u4f5c\u308d\u3046) by @AmaseCocoa</li> </ul>"},{"location":"resources/useful_links/#developer-resources","title":"Developer Resources","text":"<p>General resources that are useful when contributing to <code>apkit</code>.</p> <ul> <li>Conventional Commits: The specification for formatting commit messages, which is used in the <code>apkit</code> project.</li> </ul>"}]}